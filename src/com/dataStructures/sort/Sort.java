package com.dataStructures.sort;

/**
 * 排序
 * 
 * @author 付韶兴
 * @since 2013-1-21
 */
public interface Sort {
	/******************* 插入排序 ************************/
	/**
	 * <b>简单插入排序</b>
	 * <p>
	 * 仅有一个元素的序列总 是有序的，因此，对 n 个记录的序列，可从第二个元素开始直到第 n 个元素，逐个向有序序 列中执行插入操作，从而得到 n
	 * 个元素按关键字有序的序列。
	 * </p>
	 * 
	 * @param r
	 */
	public void insertSort(Object[] r);

	/**
	 * <b>二分法插入排序</b>
	 * <p>
	 * 原理同插入排序类似，不断二分 有序序列来确定插入位置，即搜索插入位置的方法可以使用折半查找实现。
	 * </p>
	 * 
	 * @param r
	 */
	public void binInsertSort(Object[] r);

	/**
	 * <b>希尔插入排序</b>
	 * <p>
	 * 首先将待排序的元素分为多个子序列，使得每个子序列的元素 个数相对较少，对各个子序列分别进行直接插入排序，待整个待排序序列“基本有序”后，再
	 * 对所有元素进行一次直接插入排序。
	 * </p>
	 * 
	 * @param r
	 * @param delta
	 */
	public void shellSort(Object[] r, int[] delta);

	/******************* 交换位置排序 ************************/
	/**
	 * <b>冒泡排序</b>
	 * <p>
	 * 首先，将 n 个元素中的第一个和第二个进行比较，如果两个 元素的位置为逆序，则交换两个元素的位置；进而比较第二个和第三个元素关键字，如此类
	 * 推，直到比较第 n-1 个元素和第 n 个元素为止；上述过程描述了起泡排序的第一趟排序过程，
	 * 在第一趟排序过程中，我们将关键字最大的元素通过交换操作放到了具有 n 个元素的序列的
	 * 最一个位置上。然后进行第二趟排序，在第二趟排序过程中对元素序列的前 n-1 个元素进行 相同操作，其结果是将关键字次大的元素通过交换放到第 n-1
	 * 个位置上。
	 * </p>
	 * 
	 * @param r
	 */
	public void bubbleSort(Object[] r);

	/**
	 * <b>快速排序(分治法)</b>
	 * <p>
	 * 使用两个指针 low 和 high 分别指向待划分序列 r 的 范围，取 low 所指元素为枢轴，即 pivot = r[low]。划分首先从
	 * high 所指位置的元素起向前 逐一搜索到第一个比 pivot 小的元素，并将其设置到 low 所指的位置；然后从 low 所指位置
	 * 的元素起向后逐一搜索到第一个比 pivot 大的元素，并将其设置到 high 所指的位置；不断重 复上述两步直到 low = high
	 * 为止，最后将 pivot 设置到 low 与 high 共同指向的位置。 </br>使用上述划分方法即可将待排序序列按枢轴元素 pivot
	 * 分成两个子序列，每个子序列再进行上述步骤，当然 pivot 的 选择不一定必须是 r[low]，而可以是
	 * r[low..high]之间的任何数据元素。
	 * </p>
	 * 
	 * @param r
	 */
	public void quickSort(Object[] r, int star, int end);

	/******************* 选择排序 ************************/
	/**
	 * <b>简单选择排序</b>
	 * <p>
	 * 第一趟，从 n 个元素中找出关键字最小的元素 与第一个元素交换；</br> 第二趟，在从第二个元素开始的 n-1 个元素中再选出关键字最小的元素
	 * 与第二个元素交换；</br> 如此，第 k 趟，则从第 k 个元素开始的 n-k+1 个元素中选出关键字最小 的元素与第 k
	 * 个元素交换，直到整个序列按关键字有序。
	 * </p>
	 * 
	 * @param r
	 */
	public void selectSort(Object[] r, int low, int high);

	/**
	 * <b>堆排序</b>
	 * <p>
	 * 设有 n 个元素，欲将其按关键字排序。可以首先将这 n 个元素按关键字建成堆，将堆顶 元素输出，得到 n
	 * 个元素中关键字最大（或最小）的元素。然后，再将剩下的 n-1 个元素重 新建成堆，再输出堆顶元素，得到 n
	 * 个元素中关键字次大（或次小）的元素。</br> 如此反复执行， 直到最后只剩一个元素，则可以得到一个有序序列，这个排序过程称之为堆排序。</br>
	 * 相当于每次找到序列n中的最大值与序列与n交换位置，再同理找n-1序列中最大值，放到n-1位置。查找最大值方法是用堆来查找。
	 * </p>
	 * 
	 * @param r
	 */
	public void heapSort(Object[] r);

	/**
	 * <b>归并排序</b>
	 * <p>
	 * 划分：将待排序的序列划分为大小相等（或大致相等）的两个子序列；</br> 治理：当子序列的规模大于 1 时，递归排序子序列，如果子序列规模为 1
	 * 则成为有 序序列；</br> 组合：将两个有序的子序列合并为一个有序序列。
	 * </p>
	 * 
	 * @param r
	 */
	public void mergeSort(Object[] r, int l, int h);
}
